<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>単語帳くん</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/papaparse@5.3.2/papaparse.min.js"></script>
    <style>
        body { font-family: 'Noto Sans JP', sans-serif; }
        :root, .theme-light {
            --bg-color: #f1f5f9; /* slate-100 */
            --header-bg-color: #ffffff;
            --card-bg-color: #ffffff;
            --text-color: #1e293b;
            --text-color-secondary: #64748b;
            --header-text-color: #1e293b;
            --primary-color: #0ea5e9; /* sky-500 */
            --primary-color-rgb: 14, 165, 233;
            --primary-text-color: #ffffff;
            --border-color: #e2e8f0; /* slate-200 */
            --danger-color: #ef4444;
            --danger-color-rgb: 239, 68, 68;
            --success-color: #22c55e;
            --success-color-rgb: 34, 197, 94;
            --success-bg-color: #f0fdf4;
            --danger-bg-color: #fef2f2;
            --icon-back-card-color: #cbd5e1;
            --footer-button-sub-hover-bg: #0ea5e9;
        }
        .theme-dark {
            --bg-color: #0f172a;
            --header-bg-color: #1e293b;
            --card-bg-color: #334155;
            --text-color: #e2e8f0;
            --text-color-secondary: #94a3b8;
            --header-text-color: var(--text-color);
            --primary-color: #f97316;
            --primary-color-rgb: 249, 115, 22;
            --primary-text-color: #ffffff;
            --border-color: #475569;
            --danger-color: #fca5a5;
            --danger-color-rgb: 252, 165, 165;
            --success-color: #86efac;
            --success-color-rgb: 134, 239, 172;
            --success-bg-color: #166534;
            --danger-bg-color: #7f1d1d;
            --icon-back-card-color: #e2e8f0;
            --footer-button-sub-hover-bg: #f97316;
        }
        .theme-sakura {
            --bg-color: #fdf2f8;
            --header-bg-color: #ffffff;
            --card-bg-color: #ffffff;
            --text-color: #832c56;
            --text-color-secondary: #be185d;
            --header-text-color: #832c56;
            --primary-color: #ec4899;
            --primary-color-rgb: 236, 72, 153;
            --primary-text-color: #ffffff;
            --border-color: #fbcfe8;
            --icon-back-card-color: #f9a8d4;
            --footer-button-sub-hover-bg: #db2777; 
        }
        .theme-matcha {
            --bg-color: #f7fee7;
            --header-bg-color: #ffffff;
            --card-bg-color: #ffffff;
            --text-color: #1a2e05;
            --text-color-secondary: #3f6212;
            --header-text-color: #1a2e05;
            --primary-color: #4d7c0f;
            --primary-color-rgb: 77, 124, 15;
            --primary-text-color: #ffffff;
            --border-color: #dcfce7;
            --icon-back-card-color: #a3e635;
            --footer-button-sub-hover-bg: #65a30d; 
        }
        .theme-mizu {
            --bg-color: #ecfeff;
            --header-bg-color: #ffffff;
            --card-bg-color: #ffffff;
            --text-color: #1e3a8a;
            --text-color-secondary: #1d4ed8;
            --header-text-color: #1e3a8a;
            --primary-color: #06b6d4;
            --primary-color-rgb: 6, 182, 212;
            --primary-text-color: #ffffff;
            --border-color: #a5f3fc;
            --icon-back-card-color: #67e8f9;
            --footer-button-sub-hover-bg: #0891b2; 
        }
        .theme-yuyake {
            --bg-color: #2c244d;
            --header-bg-color: #312e81;
            --card-bg-color: #4338ca;
            --text-color: #ddd6fe;
            --text-color-secondary: #a5b4fc;
            --header-text-color: var(--text-color);
            --primary-color: #f59e0b;
            --primary-color-rgb: 245, 158, 11;
            --primary-text-color: #ffffff;
            --border-color: #4f46e5;
            --icon-back-card-color: #e2e8f0;
            --footer-button-sub-hover-bg: #f59e0b;
        }
        .modal, .screen { transition: opacity 0.25s ease; }
        .hidden { display: none; }
        .flashcard-inner { transition: transform 0.6s; transform-style: preserve-3d; }
        .flashcard.is-flipped .flashcard-inner { transform: rotateY(180deg); }
        .flashcard-front, .flashcard-back { 
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
        }
        .flashcard-back { transform: rotateY(180deg); }
        #toast-container { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 1000; pointer-events: none; }
        .toast { background-color: rgba(0,0,0,0.7); color: white; padding: 10px 20px; border-radius: 20px; margin-bottom: 10px; opacity: 0; transition: opacity 0.5s; }
        .toast.show { opacity: 1; }

        .footer-button {
            transition: background-color 0.2s, color 0.2s, transform 0.2s;
        }
        .footer-button.sub {
            background-color: rgba(var(--primary-color-rgb), 0.15);
            color: var(--primary-color);
        }
        .theme-light .footer-button.sub,
        .theme-sakura .footer-button.sub,
        .theme-matcha .footer-button.sub,
        .theme-mizu .footer-button.sub {
            background-color: var(--border-color);
            color: var(--text-color-secondary);
        }
        .footer-button.sub:hover, .footer-button.sub:active {
            background-color: var(--footer-button-sub-hover-bg);
            color: var(--primary-text-color);
        }
        #unfamiliar-button, #familiar-button {
            backdrop-filter: blur(8px);
        }
        #unfamiliar-button:disabled, #familiar-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #unfamiliar-button {
            background-color: rgba(var(--danger-color-rgb), 0.1);
        }
        #familiar-button {
            background-color: rgba(var(--success-color-rgb), 0.1);
        }
        /* --- 設定画面 新デザイン --- */
        #settings-screen main { background-color: var(--bg-color); }
        .settings-card {
            background-color: var(--card-bg-color);
            border-radius: 12px;
            padding: 1rem 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        .settings-card h3 {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-color-secondary);
            margin-bottom: 0.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }
        .settings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid var(--border-color);
        }
        .settings-card > .settings-row:last-child,
        .accordion-content > .settings-row:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        .settings-card > div > .settings-row:first-of-type {
            padding-top: 0;
        }
        .settings-label {
            font-size: 0.95rem;
            color: var(--text-color);
            font-weight: 500;
        }
        .custom-toggle {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }
        .custom-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .custom-toggle .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #cbd5e1;
            transition: .4s;
            border-radius: 24px;
        }
        .custom-toggle .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .custom-toggle input:checked + .slider {
            background-color: var(--primary-color);
        }
        .custom-toggle input:checked + .slider:before {
            transform: translateX(20px);
        }
        .sliding-pill-control-wrapper {
            overflow-x: auto;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .sliding-pill-control-wrapper::-webkit-scrollbar {
            display: none;
        }
        .sliding-pill-control {
            display: inline-flex;
            position: relative;
            background-color: var(--border-color);
            border-radius: 999px;
            padding: 4px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.06);
        }
        .sliding-pill-control .option {
            padding: 0.5rem 1rem;
            cursor: pointer;
            color: var(--text-color-secondary);
            font-weight: 500;
            transition: color 0.3s ease-in-out;
            z-index: 10;
            position: relative;
            border: none;
            background: transparent;
            white-space: nowrap;
        }
        .sliding-pill-control .option.selected {
            color: var(--primary-text-color);
        }
        .sliding-pill-control .pill {
            position: absolute;
            top: 4px;
            left: 0;
            width: 0;
            height: calc(100% - 8px);
            background: var(--primary-color);
            border-radius: 999px;
            box-shadow: 0 3px 8px rgba(0,0,0,0.12);
            transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1);
        }
        .sub-settings-panel {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, margin 0.5s ease-in-out, padding 0.5s ease-in-out, border-top-width 0.1s linear 0.4s;
            margin-top: 0;
            padding-top: 0;
            border-top: 0px solid transparent;
        }
        .sub-settings-panel.active {
            max-height: 1000px; /* 十分な高さを確保 */
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
            transition: max-height 0.5s ease-in-out, margin 0.5s ease-in-out, padding 0.5s ease-in-out, border-top-width 0.1s linear;
        }
        .accordion-header { cursor: pointer; }
        .accordion-header .chevron { transition: transform 0.3s ease; }
        .accordion-header.open .chevron { transform: rotate(180deg); }
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding-top 0.4s ease-out;
            padding-top: 0;
        }
        .accordion-content.open {
            max-height: 500px;
            padding-top: 0.5rem;
        }
        .accordion-content .settings-row { padding-left: 1rem; }
        /* 円形プログレスバー */
        .progress-circle-wrapper {
            position: relative;
            width: 40px;
            height: 40px;
            cursor: pointer;
        }
        .progress-circle {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }
        .progress-circle circle {
            fill: transparent;
            stroke-width: 4;
        }
        .progress-circle .track {
            stroke: var(--border-color);
        }
        .progress-circle .fill {
            stroke: var(--primary-color);
            stroke-linecap: round;
            transition: stroke-dashoffset 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .progress-circle-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: "SF Mono", "Fira Code", "Fira Mono", "Roboto Mono", monospace;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-color-secondary);
        }
        /* --- リザルト画面 --- */
        #result-screen main { background-color: var(--bg-color); }
        #result-screen .content-wrapper {
            background-color: var(--card-bg-color);
            border-radius: 1.5rem;
            padding: 2rem 1.5rem;
            box-shadow: 0 8px 30px rgba(0,0,0,0.1);
            text-align: center;
        }
        .result-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin: 2rem 0;
        }
        .result-stat-item {
            background-color: var(--bg-color);
            padding: 1rem;
            border-radius: 12px;
            text-align: center;
        }
        .result-stat-item .label {
            font-size: 0.8rem;
            color: var(--text-color-secondary);
            margin-bottom: 0.25rem;
        }
        .result-stat-item .value {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-color);
        }
        .result-stat-item .value.correct { color: var(--success-color); }
        .result-stat-item .value.incorrect { color: var(--danger-color); }
        .progress-ring {
            position: relative;
            width: 160px;
            height: 160px;
            margin: 1.5rem auto;
        }
        .progress-ring svg { width: 100%; height: 100%; transform: rotate(-90deg); }
        .progress-ring circle { fill: transparent; stroke-width: 14; }
        .progress-ring .track { stroke: var(--border-color); }
        .progress-ring .fill {
            stroke: var(--primary-color);
            stroke-linecap: round;
            transition: stroke-dashoffset 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .progress-ring-text {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); text-align: center;
        }
        .progress-ring-text .percent { font-size: 2.25rem; font-weight: 700; color: var(--text-color); }
        .progress-ring-text .label { font-size: 0.8rem; color: var(--text-color-secondary); font-weight: 500;}
        .review-section h4 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: var(--text-color-light);
            text-align: left;
        }
        .review-list { list-style: none; padding: 0; margin: 0; text-align: left; }
        .review-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 0.25rem;
            border-bottom: 1px solid var(--bg-color);
            font-size: 0.95rem;
        }
        .review-list li:last-child { border-bottom: none; }
        .review-list .front-back-group {
            display: flex;
            flex-grow: 1;
            align-items: baseline;
            gap: 1rem;
        }
        .review-list .front { font-weight: 500; color: var(--text-color); }
        .review-list .back { color: var(--text-color-secondary); font-size: 0.9em; }
        .cta-buttons {
            margin-top: 2.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .cta-buttons button {
            width: 100%;
            padding: 0.9rem;
            border-radius: 12px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
        }
        .cta-buttons button:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .cta-buttons .btn-primary { background-color: var(--primary-color); color: white; }
        .cta-buttons .btn-secondary { background-color: var(--border-color); color: var(--text-color-light); }
        .cta-buttons .btn-tertiary { background-color: transparent; color: var(--text-color-secondary); box-shadow: none !important; }
        .cta-buttons .btn-tertiary:hover { background-color: var(--border-color); }
        .modal-content {
            background-color: var(--card-bg-color);
            padding: 1.5rem;
            border-radius: 16px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        .modal-header h4 { font-size: 1.1rem; font-weight: 600; }
        .modal-header .close-btn { font-size: 1.5rem; color: #9ca3af; cursor: pointer; border: none; background: transparent; }
        .result-list-container { max-height: 300px; overflow-y: auto; padding-right: 0.5rem; }
        /* クイズの「次へ」ボタン */
        #quiz-next-button {
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
        }
        #quiz-next-button.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
    </style>
</head>
<body class="bg-[var(--bg-color)] text-[var(--text-color)]">
    
    <div id="toast-container"></div>

    <div id="home-screen" class="screen">
        <header class="bg-[var(--header-bg-color)] shadow-md sticky top-0 z-10">
            <div class="container mx-auto px-4 h-16 flex justify-between items-center"><h1 class="text-xl font-bold text-[var(--header-text-color)]">単語帳くん</h1><button id="settings-button" class="text-[var(--header-text-color)] hover:opacity-75 p-2 rounded-full transition-opacity"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg></button></div>
        </header>
        <main class="container mx-auto p-4 pb-24 flex-grow">
            <section id="recommend-section" class="mb-8">
                <h2 class="text-lg font-bold text-[var(--primary-color)] mb-2">▼ 本日のおすすめ</h2>
                <div id="recommend-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4"></div>
            </section>
            <section>
                <div class="flex justify-between items-center mb-2">
                    <h2 class="text-lg font-bold text-[var(--primary-color)]">▼ すべての単語帳</h2>
                    <div class="relative w-1/2 sm:w-1/3">
                        <span class="absolute left-3 top-1/2 -translate-y-1/2 text-[var(--text-color-secondary)]"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg></span>
                        <input type="text" id="search-bar" placeholder="検索..." class="w-full pl-10 pr-3 py-2 bg-[var(--card-bg-color)] border border-[var(--border-color)] rounded-lg focus:outline-none focus:ring-2 focus:ring-[var(--primary-color)]">
                    </div>
                </div>
                <div id="deck-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4"><p id="deck-loading" class="text-[var(--text-color-secondary)] col-span-full">読み込み中...</p></div>
            </section>
        </main>
        <footer class="fixed bottom-0 left-0 right-0 bg-[var(--header-bg-color)] border-t border-[var(--border-color)]">
            <div class="container mx-auto px-4 h-20 flex justify-around items-center">
                <div class="flex flex-col items-center"><label class="text-xs text-[var(--header-text-color)] mb-1">出題</label><button id="home-toggle-direction" class="footer-button sub p-2 rounded-full w-14 h-14 flex items-center justify-center"></button></div>
                <div class="flex flex-col items-center"><label class="text-xs text-[var(--header-text-color)] mb-1">モード</label><button id="toggle-mode" class="footer-button sub p-2 rounded-full w-14 h-14 flex items-center justify-center"></button></div>
                <button id="add-deck-button" class="bg-[var(--primary-color)] text-[var(--primary-text-color)] rounded-full w-14 h-14 text-4xl font-light flex items-center justify-center shadow-lg hover:opacity-80 transition-opacity">+</button>
            </div>
        </footer>
    </div>
    <div id="deck-screen" class="screen hidden">
        <header class="bg-[var(--header-bg-color)] shadow-md sticky top-0 z-10">
            <div class="container mx-auto px-4 h-16 flex justify-between items-center">
                <button id="back-to-home-button" class="p-2 rounded-full hover:bg-black/10 text-[var(--header-text-color)] transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg></button>
                <h1 id="deck-title-header" class="text-xl font-bold text-[var(--header-text-color)] truncate"></h1>
                <div class="flex items-center gap-4">
                    <button id="csv-import-button" class="text-sm font-semibold border border-current rounded-full px-3 py-1 hover:bg-black/10 text-[var(--header-text-color)] transition-colors">CSVインポート</button>
                    <input type="file" id="csv-file-input" accept=".csv" class="hidden">
                    <button class="text-[var(--danger-color)] hover:opacity-75 transition-opacity" id="delete-deck-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg></button>
                </div>
            </div>
        </header>
        <main class="container mx-auto p-4 pb-24 flex-grow">
            <div id="tag-filter-bar" class="flex flex-wrap gap-2 mb-4"></div>
            <div id="card-list-container"></div>
        </main>
        <footer class="fixed bottom-0 left-0 right-0 bg-[var(--header-bg-color)] border-t border-[var(--border-color)]">
            <form id="add-card-form" class="container mx-auto px-4 h-16 flex items-center gap-2">
                <input type="text" id="new-card-front" placeholder="オモテ" class="flex-1 w-full px-3 py-2 bg-[var(--bg-color)] border border-[var(--border-color)] rounded-lg focus:outline-none focus:ring-2 focus:ring-[var(--primary-color)]">
                <input type="text" id="new-card-back" placeholder="ウラ" class="flex-1 w-full px-3 py-2 bg-[var(--bg-color)] border border-[var(--border-color)] rounded-lg focus:outline-none focus:ring-2 focus:ring-[var(--primary-color)]">
                <button type="submit" class="px-4 py-2 bg-[var(--primary-color)] text-[var(--primary-text-color)] rounded-lg font-bold">追加</button>
            </form>
        </footer>
    </div>
    <div id="study-screen" class="screen hidden flex flex-col h-screen">
         <header class="bg-[var(--header-bg-color)] container mx-auto px-4 h-16 flex justify-between items-center gap-4 flex-shrink-0">
             <div id="progress-container" class="progress-circle-wrapper">
                 <span id="progress-text" class="progress-circle-text"></span>
                 <svg id="progress-circle" class="progress-circle" viewBox="0 0 40 40">
                     <circle class="track" cx="20" cy="20" r="18"></circle>
                     <circle id="progress-fill" class="fill" cx="20" cy="20" r="18"></circle>
                 </svg>
             </div>
             <div class="flex-grow"></div>
             <button id="exit-study-button" class="p-2 rounded-full hover:bg-black/10 text-[var(--header-text-color)] transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button>
         </header>
        <main id="study-main-content" class="container mx-auto p-4 flex-grow flex flex-col items-center">
            <div id="flashcard-mode" class="w-full max-w-md flex-grow flex flex-col items-center justify-center">
                <div class="flashcard aspect-[4/3] perspective-[1000px] w-full mb-4">
                    <div id="flashcard-inner" class="flashcard-inner relative w-full h-full cursor-pointer">
                        <div id="flashcard-front" class="flashcard-front absolute w-full h-full bg-[var(--card-bg-color)] shadow-lg rounded-xl text-3xl md:text-4xl text-center"></div>
                        <div id="flashcard-back" class="flashcard-back absolute w-full h-full bg-[var(--card-bg-color)] shadow-lg rounded-xl text-3xl md:text-4xl text-center"></div>
                    </div>
                </div>
                <div id="flashcard-controls" class="w-full flex justify-around items-center gap-4 mt-8">
                    <button id="unfamiliar-button" class="flex flex-col items-center justify-center h-20 w-20 rounded-full border-2 border-[var(--danger-color)] text-[var(--danger-color)] font-bold shadow-sm" style="background-color: rgba(var(--danger-color-rgb), 0.1); backdrop-filter: blur(8px);"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg><span class="mt-1 text-xs">わからない</span></button>
                    <button id="flashcard-speak-button" class="text-4xl text-[var(--text-color-secondary)] hover:opacity-80 transition-opacity"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg></button>
                    <button id="familiar-button" class="flex flex-col items-center justify-center h-20 w-20 rounded-full border-2 border-[var(--success-color)] text-[var(--success-color)] font-bold shadow-sm" style="background-color: rgba(var(--success-color-rgb), 0.1); backdrop-filter: blur(8px);"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg><span class="mt-1 text-xs">わかった</span></button>
                </div>
            </div>
             <div id="quiz-mode" class="w-full max-w-md h-full flex-col hidden">
                <div id="quiz-question" class="w-full text-center text-3xl md:text-4xl font-semibold mb-8 cursor-pointer"></div>
                <div id="quiz-options" class="grid grid-cols-1 gap-4 w-full"></div>
                <button id="quiz-next-button" class="mt-8 px-8 py-3 rounded-lg font-bold text-[var(--primary-text-color)] bg-[var(--primary-color)]">次の問題へ</button>
            </div>
        </main>
    </div>
    <div id="settings-screen" class="screen hidden">
        <header class="bg-[var(--header-bg-color)] shadow-md sticky top-0 z-10">
            <div class="container mx-auto px-4 h-16 flex items-center">
                <button id="back-to-home-from-settings" class="p-2 rounded-full hover:bg-black/10 text-[var(--header-text-color)] transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg></button>
                <h1 class="text-xl font-bold text-[var(--header-text-color)]">設定</h1>
            </div>
        </header>
        <main class="container mx-auto p-4">
            <div class="settings-card">
                <h3>一般</h3>
                <div class="settings-row">
                    <span class="settings-label">テーマ</span>
                    <div class="sliding-pill-control-wrapper">
                        <div id="theme-selector" class="sliding-pill-control">
                            <div class="pill"></div>
                            <button class="option" data-value="theme-light">Paper</button>
                            <button class="option" data-value="theme-dark">Midnight</button>
                            <button class="option" data-value="theme-sakura">Sakura</button>
                            <button class="option" data-value="theme-matcha">Matcha</button>
                            <button class="option" data-value="theme-mizu">Ocean</button>
                            <button class="option" data-value="theme-yuyake">Twilight</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="settings-card">
                <h3>学習設定</h3>
                <div class="settings-row">
                    <span class="settings-label">出題数</span>
                    <div id="question-count-buttons" class="sliding-pill-control">
                        <div class="pill"></div>
                        <button class="option" data-value="10">10問</button>
                        <button class="option" data-value="20">20問</button>
                        <button class="option" data-value="50">50問</button>
                        <button class="option" data-value="all">すべて</button>
                    </div>
                </div>
                <div class="settings-row">
                    <span class="settings-label">出題方向</span>
                    <div id="direction-selector" class="sliding-pill-control">
                        <div class="pill"></div>
                        <button class="option" data-value="front">オモテ</button>
                        <button class="option" data-value="back">ウラ</button>
                        <button class="option" data-value="random">ランダム</button>
                    </div>
                </div>
            </div>
            <div id="speech-settings-card" class="settings-card">
                <h3>音声読み上げ</h3>
                <div class="settings-row">
                    <label for="speech-enabled-toggle" class="settings-label">音声読み上げを有効にする</label>
                    <label class="custom-toggle">
                        <input type="checkbox" id="speech-enabled-toggle">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="sub-settings-panel">
                    <div class="settings-row">
                        <label for="quiz-answer-speak-toggle" class="settings-label">解答を読み上げる</label>
                        <label class="custom-toggle">
                            <input type="checkbox" id="quiz-answer-speak-toggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="accordion-header settings-row" data-target="accordion-en">
                        <span class="settings-label">英語の音声設定</span>
                        <span class="chevron text-gray-400">▼</span>
                    </div>
                    <div id="accordion-en" class="accordion-content">
                        <div class="settings-row">
                            <label for="en-volume-slider" class="settings-label">音量: <span id="en-volume-value">1.0</span></label>
                            <input type="range" id="en-volume-slider" min="0" max="1" step="0.1" value="1" class="w-1/2">
                        </div>
                        <div class="settings-row">
                            <label for="en-rate-slider" class="settings-label">速度: <span id="en-rate-value">1.0</span></label>
                            <input type="range" id="en-rate-slider" min="0.5" max="2" step="0.1" value="1" class="w-1/2">
                        </div>
                         <div class="settings-row">
                            <label for="en-voice-select" class="settings-label">音声の種類</label>
                            <select id="en-voice-select" class="w-1/2 p-2 rounded-lg border border-[var(--border-color)] bg-[var(--bg-color)]"></select>
                        </div>
                    </div>
                    <div class="accordion-header settings-row" data-target="accordion-ja">
                        <span class="settings-label">日本語の音声設定</span>
                        <span class="chevron text-gray-400">▼</span>
                    </div>
                     <div id="accordion-ja" class="accordion-content">
                        <div class="settings-row">
                            <label for="ja-volume-slider" class="settings-label">音量: <span id="ja-volume-value">1.0</span></label>
                            <input type="range" id="ja-volume-slider" min="0" max="1" step="0.1" value="1" class="w-1/2">
                        </div>
                        <div class="settings-row">
                            <label for="ja-rate-slider" class="settings-label">速度: <span id="ja-rate-value">1.0</span></label>
                            <input type="range" id="ja-rate-slider" min="0.5" max="2" step="0.1" value="1" class="w-1/2">
                        </div>
                        <div class="settings-row">
                            <label for="ja-voice-select" class="settings-label">音声の種類</label>
                            <select id="ja-voice-select" class="w-1/2 p-2 rounded-lg border border-[var(--border-color)] bg-[var(--bg-color)]"></select>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
    <div id="result-screen" class="screen hidden flex flex-col h-screen">
        <main class="container mx-auto p-4 flex-grow flex items-center">
            <div class="content-wrapper w-full">
                <h2 class="text-2xl font-bold text-center mb-2">学習結果</h2>
                <div id="result-progress-ring" class="progress-ring">
                    <div class="progress-ring-text">
                        <div id="result-accuracy-percent" class="percent"></div>
                        <div class="label">正解率</div>
                    </div>
                    <svg>
                        <circle class="track" cx="80" cy="80" r="73"></circle>
                        <circle id="result-progress-fill" class="fill" cx="80" cy="80" r="73"></circle>
                    </svg>
                </div>
                <div class="result-stats">
                    <div class="result-stat-item"><div class="label">学習時間</div><div id="result-time" class="value"></div></div>
                    <div class="result-stat-item"><div class="label">正解</div><div id="result-correct-count" class="value correct"></div></div>
                    <div class="result-stat-item"><div class="label">不正解</div><div id="result-incorrect-count" class="value incorrect"></div></div>
                </div>
                <div class="cta-buttons">
                    <button id="retry-incorrect-button" class="btn-primary">間違えた単語を復習</button>
                    <button id="show-details-button" class="btn-secondary">詳細</button>
                    <button id="result-back-to-home-button" class="btn-tertiary">ホームに戻る</button>
                </div>
            </div>
        </main>
    </div>

    <div id="add-deck-modal" class="modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 opacity-0 pointer-events-none">
        <div class="modal-content">
            <h3 class="text-xl font-bold mb-4">新しい単語帳を作成</h3>
            <input type="text" id="new-deck-title-input" placeholder="単語帳のタイトル" class="w-full px-3 py-2 border border-[var(--border-color)] rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-[var(--primary-color)]">
            <div class="flex justify-end gap-2">
                <button class="cancel-modal-button px-4 py-2 rounded-lg">キャンセル</button>
                <button id="confirm-add-deck" class="px-4 py-2 bg-[var(--primary-color)] text-[var(--primary-text-color)] rounded-lg hover:opacity-80 transition-colors">作成</button>
            </div>
        </div>
    </div>
    <div id="confirm-modal" class="modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 opacity-0 pointer-events-none">
        <div class="modal-content">
            <h3 id="confirm-modal-title" class="text-lg font-bold mb-4"></h3>
            <div class="flex justify-end gap-2">
                <button class="cancel-modal-button px-4 py-2 rounded-lg">キャンセル</button>
                <button id="confirm-modal-ok" class="px-4 py-2 bg-[var(--danger-color)] text-white rounded-lg">OK</button>
            </div>
        </div>
    </div>
    <div id="details-modal" class="modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 opacity-0 pointer-events-none">
        <div class="modal-content">
            <div class="modal-header">
                <h4 id="details-list-title"></h4>
                <button id="close-details-modal" class="close-btn">&times;</button>
            </div>
            <div id="details-list-container" class="result-list-container"></div>
        </div>
    </div>


    <script type="module">
        import { openDB } from 'https://unpkg.com/idb@7.1.1/build/index.js';
        
        // --- アプリのエントリーポイント ---
        document.addEventListener('DOMContentLoaded', initializeApp);

        // --- グローバルステート ---
        let db;
        let audioContext;
        let currentSession = null;
        const state = {
            allDecksCache: [],
            currentDeckId: null,
            currentDeckCards: [],
            currentTagFilter: null,
            uiSettings: { 
                theme: 'theme-light', 
                learningMode: 'card', 
                cardDirection: 'front',
                speechEnabled: true, 
                questionCount: 'all',
                enRate: 1.0,
                jaRate: 1.0,
                enVolume: 1.0,
                jaVolume: 1.0,
                enVoice: null,
                jaVoice: null,
                quizAnswerReadAloud: false,
            }
        };

        // --- DOM要素 ---
        const dom = {};
        
        // --- データベース (IndexedDB) ラッパー ---
        const DB_NAME = 'tangochokun-db';
        const DB_VERSION = 1;
        const DECK_STORE = 'decks';
        const CARD_STORE = 'cards';
        
        const dbOps = {
            async initDB() {
                db = await openDB(DB_NAME, DB_VERSION, {
                    upgrade(db) {
                        if (!db.objectStoreNames.contains(DECK_STORE)) {
                            db.createObjectStore(DECK_STORE, { keyPath: 'id', autoIncrement: true });
                        }
                        if (!db.objectStoreNames.contains(CARD_STORE)) {
                            const store = db.createObjectStore(CARD_STORE, { keyPath: 'id', autoIncrement: true });
                            store.createIndex('deckId', 'deckId', { unique: false });
                        }
                    },
                });
            },
            async getDecks() { return await db.getAll(DECK_STORE); },
            async getDeck(id) { return await db.get(DECK_STORE, id); },
            async addDeck(deck) { return await db.add(DECK_STORE, deck); },
            async updateDeck(deck) { return await db.put(DECK_STORE, deck); },
            async getAllCards() { return await db.getAll(CARD_STORE); },
            async getCardsByDeck(deckId) { return await db.getAllFromIndex(CARD_STORE, 'deckId', deckId); },
            async getCard(id) { return await db.get(CARD_STORE, id); },
            async addCard(card) { return await db.add(CARD_STORE, card); },
            async deleteCard(cardId) { return await db.delete(CARD_STORE, cardId); },
            async updateCard(card) { return await db.put(CARD_STORE, card); },
            async deleteDeck(deckId) {
                const tx = db.transaction([DECK_STORE, CARD_STORE], 'readwrite');
                const cardStore = tx.objectStore(CARD_STORE);
                const cardIndex = cardStore.index('deckId');
                const cardsToDelete = await cardIndex.getAllKeys(deckId);
                await Promise.all([
                    ...cardsToDelete.map(key => cardStore.delete(key)),
                    tx.objectStore(DECK_STORE).delete(deckId)
                ]);
                await tx.done;
            }
        };

        // --- UI・ロジックのコア関数 ---
        const showScreen = (screenName) => {
             speechSynthesis.cancel();
             Object.values(dom.screens).forEach(s => s.classList.add('hidden'));
             const targetScreen = document.getElementById(`${screenName}-screen`);
             if(targetScreen) targetScreen.classList.remove('hidden');
         }

        const showToast = (message, duration = 3000) => {
            const toastContainer = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            toastContainer.appendChild(toast);
            setTimeout(() => { toast.classList.add('show'); }, 10);
            setTimeout(() => {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => toast.remove());
            }, duration);
        }

        const loadSettings = () => {
            Object.keys(state.uiSettings).forEach(key => {
                const savedValue = localStorage.getItem(key);
                if (savedValue) {
                    if (key.includes('Rate') || key.includes('Volume')) {
                        state.uiSettings[key] = parseFloat(savedValue);
                    } else if (typeof state.uiSettings[key] === 'boolean') {
                        state.uiSettings[key] = savedValue === 'true';
                    } else {
                        state.uiSettings[key] = savedValue;
                    }
                }
            });
            updateTheme();
            updateModeButton();
            updateDirectionUI();
        }
        
        const saveSetting = (key, value) => {
            state.uiSettings[key] = value;
            localStorage.setItem(key, value);
        }
        
        const updateTheme = () => { 
            document.body.className = `bg-[var(--bg-color)] text-[var(--text-color)]`;
            document.body.classList.add(state.uiSettings.theme);
        }
        const updateModeButton = () => { dom.toggleMode.innerHTML = state.uiSettings.learningMode === 'card' ? '<svg viewBox="0 0 70 60" class="w-8 h-8"><title>重ねたカードのアイコン</title><rect x="5" y="15" width="50" height="35" rx="5" fill="var(--icon-back-card-color)" stroke="currentColor" stroke-width="1.5"/><rect x="15" y="5" width="50" height="35" rx="5" fill="var(--card-bg-color)" stroke="currentColor" stroke-width="1.5"/></svg>' : '<svg viewBox="0 0 70 60" class="w-8 h-8"><title>選択肢グリッドのアイコン</title><rect x="10" y="5" width="22" height="22" rx="4" fill="var(--card-bg-color)" stroke="currentColor" stroke-width="1.5"/><rect x="38" y="5" width="22" height="22" rx="4" fill="var(--card-bg-color)" stroke="currentColor" stroke-width="1.5"/><rect x="10" y="33" width="22" height="22" rx="4" fill="var(--card-bg-color)" stroke="currentColor" stroke-width="1.5"/><g><rect x="38" y="33" width="22" height="22" rx="4" fill="var(--success-color)"/><path d="M44 44 l4 4 l8 -8" stroke="var(--primary-text-color)" stroke-width="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/></g></svg>'; }
        
        const updateDirectionUI = () => {
            const icons = {
                front: `<svg viewBox="0 0 100 100" class="w-12 h-12"><title>表から裏へ</title><rect x="60" y="60" width="35" height="35" rx="3" fill="var(--icon-back-card-color)" stroke="var(--text-color-secondary)" stroke-width="1.5"/><rect x="15" y="15" width="50" height="50" rx="5" fill="var(--card-bg-color)" stroke="var(--text-color-secondary)" stroke-width="2"/><g><path d="M 65 40 L 72.5 40 A 5 5 0 0 1 77.5 45 V 57.5" stroke="var(--card-bg-color)" stroke-width="8" fill="none" stroke-linecap="round" stroke-linejoin="round"/><path d="M 74.5 57.5 L 77.5 60.5 L 80.5 57.5" stroke="var(--card-bg-color)" stroke-width="8" fill="none" stroke-linecap="round" stroke-linejoin="round"/></g><g><path d="M 65 40 L 72.5 40 A 5 5 0 0 1 77.5 45 V 57.5" stroke="var(--text-color-secondary)" stroke-width="4" fill="none" stroke-linecap="round" stroke-linejoin="round"/><path d="M 74.5 57.5 L 77.5 60.5 L 80.5 57.5" fill="none" stroke="var(--text-color-secondary)" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/></g></svg>`,
                back: `<svg viewBox="0 0 100 100" class="w-12 h-12"><title>裏から表へ</title><rect x="60" y="60" width="35" height="35" rx="3" fill="var(--card-bg-color)" stroke="var(--text-color-secondary)" stroke-width="1.5"/><rect x="15" y="15" width="50" height="50" rx="5" fill="var(--icon-back-card-color)" stroke="var(--text-color-secondary)" stroke-width="2"/><g><path d="M 40 65 V 72.5 A 5 5 0 0 0 45 77.5 H 57.5" stroke="var(--icon-back-card-color)" stroke-width="8" fill="none" stroke-linecap="round" stroke-linejoin="round"/><path d="M 57.5 74.5 L 60.5 77.5 L 57.5 80.5" stroke="var(--icon-back-card-color)" stroke-width="8" fill="none" stroke-linecap="round" stroke-linejoin="round"/></g><g><path d="M 40 65 V 72.5 A 5 5 0 0 0 45 77.5 H 57.5" stroke="var(--text-color-secondary)" stroke-width="4" fill="none" stroke-linecap="round" stroke-linejoin="round"/><path d="M 57.5 74.5 L 60.5 77.5 L 57.5 80.5" fill="none" stroke="var(--text-color-secondary)" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/></g></svg>`,
                random: `<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="w-8 h-8"><rect x="3" y="3" width="18" height="18" rx="2"></rect><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><path d="M12 17h.01"></path></svg>`
            };
            dom.homeToggleDirection.innerHTML = icons[state.uiSettings.cardDirection] || icons.front;
            updateSettingsUI();
        }

        const escapeHTML = (str) => typeof str === 'string' ? str.replace(/[&<>"']/g, match => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[match])) : '';
        
        const renderDecks = (decks) => {
             dom.deckGrid.innerHTML = '';
             const fragment = document.createDocumentFragment();
             const term = dom.searchBar.value.toLowerCase();
             const filtered = decks.filter(d => d.title.toLowerCase().includes(term));
             
             if (filtered.length === 0) {
                 dom.deckGrid.innerHTML = `<p class="text-[var(--text-color-secondary)] col-span-full">単語帳がありません。</p>`;
                 return;
             }

             filtered.forEach(deck => {
                 const progress = deck.progress || 0;
                 const el = document.createElement('div');
                 el.className = 'bg-[var(--card-bg-color)] rounded-lg p-4 shadow-md flex flex-col justify-between cursor-pointer';
                 el.innerHTML = `<div><h3 class="font-bold text-md mb-2 truncate">${escapeHTML(deck.title)}</h3><div class="w-full bg-gray-200 rounded-full h-2.5"><div class="bg-[var(--primary-color)] h-2.5 rounded-full" style="width: ${progress}%"></div></div></div><div class="flex justify-between items-center text-sm text-[var(--text-color-secondary)]"><span>進捗: ${progress}%</span><button data-deck-id="${deck.id}" class="play-button text-xl text-[var(--primary-color)] font-bold">▶</button></div>`;
                 el.querySelector('.play-button').addEventListener('click', (e) => { e.stopPropagation(); startLearningSession(deck.id, 'all'); });
                 el.addEventListener('click', () => showDeckScreen(deck.id, deck.title));
                 fragment.appendChild(el);
             });

             dom.deckGrid.appendChild(fragment);
         }

        const refreshDecks = async () => {
            state.allDecksCache = await dbOps.getDecks();
            state.allDecksCache.sort((a, b) => b.createdAt - a.createdAt);
            await updateRecommendations();
            renderDecks(state.allDecksCache);
        }

        const checkAndCreateSampleData = async () => {
            const decks = await dbOps.getDecks();
            if (decks.length === 0) {
                const deckId = await dbOps.addDeck({ title: '基本的な英単語', createdAt: Date.now(), progress: 0 });
                const sampleCards = [
                    { deckId, front: 'apple', back: 'りんご', createdAt: Date.now(), consecutiveCorrect: 0, nextReviewDate: Date.now(), nigatescore: 0, tags: ['#fruit'] },
                    { deckId, front: 'book', back: '本', createdAt: Date.now(), consecutiveCorrect: 0, nextReviewDate: Date.now(), nigatescore: 0, tags: ['#noun'] },
                    { deckId, front: 'car', back: '車', createdAt: Date.now(), consecutiveCorrect: 0, nextReviewDate: Date.now(), nigatescore: 0, tags: ['#vehicle'] },
                    { deckId, front: 'dog', back: '犬', createdAt: Date.now(), consecutiveCorrect: 0, nextReviewDate: Date.now(), nigatescore: 0, tags: ['#animal'] },
                    { deckId, front: 'egg', back: '卵', createdAt: Date.now(), consecutiveCorrect: 0, nextReviewDate: Date.now(), nigatescore: 0, tags: ['#food'] },
                ];
                for (const card of sampleCards) {
                    await dbOps.addCard(card);
                }
            }
        }
        
        const showDeckScreen = async (deckId, deckTitle) => {
            state.currentDeckId = deckId;
            dom.deckTitleHeader.textContent = deckTitle;
            state.currentDeckCards = await dbOps.getCardsByDeck(deckId);
            renderTagFilters();
            renderCards();
            showScreen('deck');
        }

        const renderCards = () => {
            dom.cardListContainer.innerHTML = '';
            const fragment = document.createDocumentFragment();

            if (state.currentDeckCards.length === 0) {
                dom.cardListContainer.innerHTML = `<p class="text-[var(--text-color-secondary)] text-center mt-8">単語がありません。</p>`;
                return;
            }
            const filteredCards = state.currentTagFilter 
                ? state.currentDeckCards.filter(card => card.tags && card.tags.includes(state.currentTagFilter)) 
                : state.currentDeckCards;

            filteredCards.forEach(card => {
                const cardItem = document.createElement('div');
                cardItem.className = 'card-item bg-[var(--card-bg-color)] rounded-lg p-3 mb-3 shadow-sm';
                cardItem.dataset.cardId = card.id;
                cardItem.innerHTML = createCardView(card);
                fragment.appendChild(cardItem);
            });
            dom.cardListContainer.appendChild(fragment);
        }

        const createCardView = (card) => {
            const tagsHtml = (card.tags || []).map(tag => `<span class="bg-gray-200 text-gray-700 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded">${escapeHTML(tag)}</span>`).join('');
            const history = (card.history || []).map(h => `<span class="inline-block w-3 h-3 rounded-full ${h ? 'bg-green-500' : 'bg-red-500'}"></span>`).join('');
            const editIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>`;
            const deleteIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>`;
            return `<div class="flex items-center"><div class="flex-1 border-r border-gray-200 pr-3 mr-3 cursor-pointer card-front-div"><div class="text-xs text-[var(--text-color-secondary)]">オモテ</div><div class="card-front-text font-medium">${escapeHTML(card.front)}</div></div><div class="flex-1 cursor-pointer card-back-div"><div class="text-xs text-[var(--text-color-secondary)]">ウラ</div><div class="card-back-text font-medium">${escapeHTML(card.back)}</div></div><div class="flex items-center gap-2 ml-2"><div class="flex gap-1">${history}</div><button class="edit-card-button text-[var(--text-color-secondary)] hover:text-sky-500 p-1">${editIcon}</button><button class="delete-card-button text-[var(--text-color-secondary)] hover:text-red-500 p-1">${deleteIcon}</button></div></div><div class="mt-2">${tagsHtml}</div>`;
        }
        
        const createCardEditView = (card) => {
            const tagsStr = (card.tags || []).join(', ');
            return `
                <div class="flex flex-col gap-2">
                     <input class="edit-front-input w-full px-2 py-1 border border-[var(--border-color)] rounded-md bg-[var(--bg-color)]" value="${escapeHTML(card.front)}">
                     <input class="edit-back-input w-full px-2 py-1 border border-[var(--border-color)] rounded-md bg-[var(--bg-color)]" value="${escapeHTML(card.back)}">
                     <input class="edit-tags-input w-full px-2 py-1 border border-[var(--border-color)] rounded-md bg-[var(--bg-color)]" placeholder="タグ (例: #fruit, #food)" value="${escapeHTML(tagsStr)}">
                </div>
                <div class="flex justify-end gap-3 mt-4">
                    <button class="cancel-edit-button px-4 py-1.5 text-sm font-semibold rounded-md bg-slate-200 text-slate-700 hover:bg-slate-300">キャンセル</button>
                    <button class="save-card-button px-4 py-1.5 text-sm font-semibold rounded-md bg-sky-500 text-white hover:bg-sky-600">保存する</button>
                </div>
            `;
        };
        
        const startLearningSession = async (deckId, sessionType = 'all', cardSet = null) => {
             currentSession = new StudySession(deckId, sessionType);
             await currentSession.prepare(cardSet);
             if (currentSession.isValid()) {
                 currentSession.start();
             } else {
                 currentSession = null;
             }
        };

        const updateProgressDisplay = () => {
            if (!currentSession) return;
            const { currentIndex, cards } = currentSession;
            const current = currentIndex + 1;
            const total = cards.length;
            const percentage = total > 0 ? (current / total) * 100 : 0;
            
            const fill = document.getElementById('progress-fill');
            const text = document.getElementById('progress-text');
            const circumference = 2 * Math.PI * 18; // r=18
            
            fill.style.strokeDasharray = circumference;
            fill.style.strokeDashoffset = circumference * (1 - (percentage / 100));
            text.textContent = `${current}/${total}`;
        };
        
        const showResultScreen = async () => {
            if (!currentSession) return;
            const { correctCards, incorrectCards, cards, startTime, deckId } = currentSession;
            const total = cards.length;
            const accuracy = total > 0 ? Math.round((correctCards.length / total) * 100) : 0;
            const time = Math.round((Date.now() - startTime) / 1000);
            const minutes = Math.floor(time / 60);
            const seconds = time % 60;
            
            const fill = dom.resultScreen.fill;
            const circumference = 2 * Math.PI * 73;
            fill.style.strokeDasharray = circumference;
            requestAnimationFrame(() => {
                fill.style.strokeDashoffset = circumference * (1 - (accuracy / 100));
            });
            
            dom.resultScreen.accuracyPercent.textContent = `${accuracy}%`;
            dom.resultScreen.time.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            dom.resultScreen.correctCount.textContent = correctCards.length;
            dom.resultScreen.incorrectCount.textContent = incorrectCards.length;
            
            dom.resultScreen.retryButton.style.display = incorrectCards.length > 0 ? 'block' : 'none';
            dom.resultScreen.detailsButton.style.display = cards.length > 0 ? 'block' : 'none';

            showScreen('result');
            
            if (deckId && currentSession.sessionType !== 'retry') {
                await updateDeckProgress(deckId);
            }
        };

        async function updateDeckProgress(deckId) {
            const deck = await dbOps.getDeck(deckId);
            if (!deck) return;

            const cards = await dbOps.getCardsByDeck(deckId);
            const total = cards.length;
            if (total === 0) {
                deck.progress = 0;
            } else {
                const totalPoints = cards.reduce((sum, card) => {
                    const correctCount = card.consecutiveCorrect || 0;
                    if (correctCount === 1) return sum + 33;
                    if (correctCount === 2) return sum + 66;
                    if (correctCount >= 3) return sum + 100;
                    return sum;
                }, 0);
                deck.progress = Math.round(totalPoints / total);
            }
            await dbOps.updateDeck(deck);
        }

        const updateRecommendations = async () => {
            const allCards = await dbOps.getAllCards();
            const now = Date.now();
            
            const reviewCardsByDeck = {};

            for (const card of allCards) {
                if ((card.nextReviewDate || 0) <= now || (card.nigatescore || 0) >= 5) {
                    if(!reviewCardsByDeck[card.deckId]) reviewCardsByDeck[card.deckId] = 0;
                    reviewCardsByDeck[card.deckId]++;
                }
            }
            
            const recommendGrid = document.getElementById('recommend-grid');
            const recommendSection = document.getElementById('recommend-section');
            recommendGrid.innerHTML = ''; 
            const fragment = document.createDocumentFragment();
            
            const recommendDeckIds = Object.keys(reviewCardsByDeck).map(Number);
            
            if (recommendDeckIds.length === 0) {
                recommendSection.style.display = 'none';
                return;
            }
            
            recommendSection.style.display = 'block';
            recommendDeckIds.forEach(deckId => {
                const deck = state.allDecksCache.find(d => d.id === deckId);
                if (deck) {
                    const reviewCount = reviewCardsByDeck[deckId] || 0;
                    const el = document.createElement('div');
                    el.className = 'bg-[var(--card-bg-color)] rounded-lg p-4 shadow-md cursor-pointer';
                    el.innerHTML = `<div class="font-bold text-md mb-2 truncate">${escapeHTML(deck.title)}</div><div class="text-sm text-[var(--text-color-secondary)]">復習: ${reviewCount}枚</div>`;
                    el.addEventListener('click', () => startLearningSession(deck.id, 'review'));
                    fragment.appendChild(el);
                }
            });
            recommendGrid.appendChild(fragment);
        };
        
        const renderTagFilters = () => {
            const tagFilterBar = document.getElementById('tag-filter-bar');
            const allTags = new Set(state.currentDeckCards.flatMap(card => card.tags || []));
            tagFilterBar.innerHTML = '';
            
            const createButton = (text, tag) => {
                const button = document.createElement('button');
                button.textContent = text;
                button.dataset.tag = tag;
                const isActive = state.currentTagFilter === tag;
                button.className = `px-3 py-1 text-sm rounded-full ${isActive ? 'bg-[var(--primary-color)] text-[var(--primary-text-color)]' : 'bg-gray-200 text-gray-700'}`;
                return button;
            };

            const fragment = document.createDocumentFragment();
            fragment.appendChild(createButton('すべて表示', null));
            allTags.forEach(tag => fragment.appendChild(createButton(tag, tag)));
            tagFilterBar.appendChild(fragment);
        };
        
        const detectLang = (text) => {
            const jpRegex = /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/;
            return jpRegex.test(text) ? 'ja-JP' : 'en-US';
        };

        const playSound = (isCorrect) => {
            if (!audioContext || !state.uiSettings.speechEnabled) return;
            
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            const now = audioContext.currentTime;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            const duration = isCorrect ? 0.2 : 0.4;
            oscillator.type = isCorrect ? 'sine' : 'sawtooth';
            oscillator.frequency.setValueAtTime(isCorrect ? 800 : 200, now);
            gainNode.gain.setValueAtTime(0.1, now);
            gainNode.gain.exponentialRampToValueAtTime(0.00001, now + duration);
            
            oscillator.start(now);
            oscillator.stop(now + duration);
        };


        const speak = (text) => {
            if (!state.uiSettings.speechEnabled || !('speechSynthesis' in window) || speechSynthesis.speaking) { return; }
            const utterance = new SpeechSynthesisUtterance(text);
            const lang = detectLang(text);
            utterance.lang = lang;
            
            if (lang === 'ja-JP') {
                utterance.rate = state.uiSettings.jaRate;
                utterance.volume = state.uiSettings.jaVolume;
                const voice = speechSynthesis.getVoices().find(v => v.name === state.uiSettings.jaVoice);
                if(voice) utterance.voice = voice;
            } else {
                utterance.rate = state.uiSettings.enRate;
                utterance.volume = state.uiSettings.enVolume;
                const voice = speechSynthesis.getVoices().find(v => v.name === state.uiSettings.enVoice);
                if(voice) utterance.voice = voice;
            }

            speechSynthesis.speak(utterance);
        };

        const populateVoiceList = () => {
            const enSelect = document.getElementById('en-voice-select');
            const jaSelect = document.getElementById('ja-voice-select');
            enSelect.innerHTML = '';
            jaSelect.innerHTML = '';

            const voices = speechSynthesis.getVoices();
            voices.forEach(voice => {
                const option = document.createElement('option');
                option.textContent = `${voice.name} (${voice.lang})`;
                option.value = voice.name;
                if (voice.lang.startsWith('en')) {
                    enSelect.appendChild(option);
                } else if (voice.lang.startsWith('ja')) {
                    jaSelect.appendChild(option);
                }
            });
            if (state.uiSettings.enVoice) enSelect.value = state.uiSettings.enVoice;
            if (state.uiSettings.jaVoice) jaSelect.value = state.uiSettings.jaVoice;
        };
        
        const setupSlidingPillControl = (containerId, settingKey, onUpdate) => {
            const control = document.getElementById(containerId);
            if (!control) return;

            const pill = control.querySelector('.pill');
            const options = control.querySelectorAll('.option');

            options.forEach(option => {
                option.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const value = option.dataset.value;
                    saveSetting(settingKey, value);
                    if (onUpdate) {
                       onUpdate();
                    }
                    updateSettingsUI();
                });
            });
        };

        const updateSettingsUI = () => {
            document.getElementById('speech-enabled-toggle').checked = state.uiSettings.speechEnabled;
            document.getElementById('quiz-answer-speak-toggle').checked = state.uiSettings.quizAnswerReadAloud;
            document.getElementById('en-rate-slider').value = state.uiSettings.enRate;
            document.getElementById('en-rate-value').textContent = state.uiSettings.enRate.toFixed(1);
            document.getElementById('ja-rate-slider').value = state.uiSettings.jaRate;
            document.getElementById('ja-rate-value').textContent = state.uiSettings.jaRate.toFixed(1);
            document.getElementById('en-volume-slider').value = state.uiSettings.enVolume;
            document.getElementById('en-volume-value').textContent = state.uiSettings.enVolume.toFixed(1);
            document.getElementById('ja-volume-slider').value = state.uiSettings.jaVolume;
            document.getElementById('ja-volume-value').textContent = state.uiSettings.jaVolume.toFixed(1);
            
            requestAnimationFrame(() => {
                ['theme-selector', 'question-count-buttons', 'direction-selector'].forEach(id => {
                    const control = document.getElementById(id);
                    if(!control) return;
                    let settingKey;
                    if (id === 'theme-selector') settingKey = 'theme';
                    else if (id === 'question-count-buttons') settingKey = 'questionCount';
                    else if (id === 'direction-selector') settingKey = 'cardDirection';
                    
                    const selectedOption = control.querySelector(`.option[data-value="${state.uiSettings[settingKey]}"]`);
                    if (selectedOption) {
                        const pill = control.querySelector('.pill');
                        pill.style.left = `${selectedOption.offsetLeft}px`;
                        pill.style.width = `${selectedOption.offsetWidth}px`;
                        control.querySelectorAll('.option').forEach(o => o.classList.remove('selected'));
                        selectedOption.classList.add('selected');
                    }
                });
            });
            
            const speechSubPanel = document.querySelector('#speech-settings-card .sub-settings-panel');
            speechSubPanel.classList.toggle('active', state.uiSettings.speechEnabled);

            populateVoiceList();
        };

        const showConfirmModal = (title, onConfirm) => {
            const modal = document.getElementById('confirm-modal');
            modal.querySelector('#confirm-modal-title').textContent = title;
            modal.classList.remove('opacity-0', 'pointer-events-none');

            const okButton = modal.querySelector('#confirm-modal-ok');
            modal.querySelector('.cancel-modal-button').onclick = () => modal.classList.add('opacity-0', 'pointer-events-none');

            okButton.onclick = () => {
                onConfirm();
                modal.classList.add('opacity-0', 'pointer-events-none');
            };
        }

        const handleCsvImport = async (file) => {
            if (!state.currentDeckId) return showToast("単語帳を選択してください。");
            Papa.parse(file, {
                complete: async (results) => {
                    let importedCount = 0;
                    for (const row of results.data) {
                        const front = row[0] && row[0].trim();
                        const back = row[1] && row[1].trim();
                        if (front && back) {
                            await dbOps.addCard({ deckId: state.currentDeckId, front, back, createdAt: Date.now(), consecutiveCorrect: 0, nextReviewDate: Date.now(), nigatescore: 0, tags: [] });
                            importedCount++;
                        }
                    }
                    if (importedCount > 0) {
                        showToast(`${importedCount} 件の単語をインポートしました。`);
                        state.currentDeckCards = await dbOps.getCardsByDeck(state.currentDeckId);
                        renderCards();
                        renderTagFilters();
                    } else {
                        showToast("インポートできる有効なデータがありませんでした。", 4000);
                    }
                }
            });
        }
        
        class StudySession {
            constructor(deckId, sessionType) {
                this.deckId = deckId;
                this.sessionType = sessionType;
                this.cards = [];
                this.originalCards = [];
                this.currentIndex = 0;
                this.startTime = 0;
                this.correctCards = [];
                this.incorrectCards = [];
                this.isAnswered = false;
                this.isProcessing = false;
            }

            async prepare(cardSet = null) {
                if (cardSet) {
                    this.cards = [...cardSet];
                    const allDeckCards = await dbOps.getCardsByDeck(this.deckId);
                    this.originalCards = [...allDeckCards];
                } else {
                    if (this.sessionType === 'review') {
                        const deckCards = await dbOps.getCardsByDeck(this.deckId);
                        const now = Date.now();
                        this.cards = deckCards.filter(c => (c.nextReviewDate || 0) <= now || (c.nigatescore || 0) >= 5);
                        this.originalCards = [...deckCards];
                    } else {
                        this.cards = await dbOps.getCardsByDeck(this.deckId);
                        if (state.currentTagFilter) {
                            this.cards = this.cards.filter(card => card.tags && card.tags.includes(state.currentTagFilter));
                        }
                        this.originalCards = [...this.cards];
                    }
                }

                this.cards.sort(() => Math.random() - 0.5);

                const count = parseInt(state.uiSettings.questionCount, 10);
                if (this.sessionType !== 'retry' && !isNaN(count) && this.cards.length > count) {
                    this.cards = this.cards.slice(0, count);
                }
            }

            isValid() {
                if (this.cards.length === 0) {
                    showToast("学習するカードがありません。");
                    return false;
                }
                if (state.uiSettings.learningMode === 'quiz' && this.originalCards.length < 4) {
                    showToast("クイズの選択肢を作成するのに十分なカードが単語帳にありません。");
                    return false;
                }
                return true;
            }

            start() {
                this.startTime = Date.now();
                showScreen('study');
                if (state.uiSettings.learningMode === 'card') {
                    dom.flashcardMode.style.display = 'flex';
                    dom.quizMode.style.display = 'none';
                    this.showFlashcard();
                } else {
                    dom.flashcardMode.style.display = 'none';
                    dom.quizMode.style.display = 'flex';
                    this.showQuiz();
                }
            }

            showFlashcard() {
                dom.flashcardInner.parentElement.classList.remove('is-flipped');
                setTimeout(() => {
                    if (this.currentIndex >= this.cards.length) return;
                    const cardData = this.cards[this.currentIndex];
                    let question, answer;
                    if(state.uiSettings.cardDirection === 'random'){
                        if(Math.random() < 0.5){
                            question = cardData.front;
                            answer = cardData.back;
                        } else {
                            question = cardData.back;
                            answer = cardData.front;
                        }
                    } else {
                         question = state.uiSettings.cardDirection === 'front' ? cardData.front : cardData.back;
                         answer = state.uiSettings.cardDirection === 'front' ? cardData.back : cardData.front;
                    }
                    
                    dom.flashcardFront.textContent = question;
                    dom.flashcardBack.textContent = answer;
                    updateProgressDisplay();
                    speak(question);
                    this.isProcessing = false;
                }, 300);
            }

            showQuiz() {
                if (this.currentIndex >= this.cards.length) return;
                this.isAnswered = false;
                dom.quizNextButton.classList.remove('visible');
                
                const card = this.cards[this.currentIndex];
                let questionText, correctAnswer, answerSide;

                if (state.uiSettings.cardDirection === 'random') {
                    if (Math.random() < 0.5) {
                        questionText = card.front;
                        correctAnswer = card.back;
                        answerSide = 'back';
                    } else {
                        questionText = card.back;
                        correctAnswer = card.front;
                        answerSide = 'front';
                    }
                } else {
                    questionText = state.uiSettings.cardDirection === 'front' ? card.front : card.back;
                    correctAnswer = state.uiSettings.cardDirection === 'front' ? card.back : card.front;
                    answerSide = state.uiSettings.cardDirection === 'front' ? 'back' : 'front';
                }

                const distractors = this.originalCards
                    .filter(c => c.id !== card.id)
                    .sort(() => 0.5 - Math.random())
                    .slice(0, 3)
                    .map(c => c[answerSide]);

                const options = [...new Set([correctAnswer, ...distractors])].sort(() => 0.5 - Math.random());
                
                dom.quizQuestion.textContent = questionText;
                dom.quizOptions.innerHTML = '';
                const fragment = document.createDocumentFragment();
                options.forEach(text => {
                    const button = document.createElement('button');
                    button.className = "w-full p-4 bg-[var(--card-bg-color)] border-2 border-[var(--border-color)] rounded-lg text-lg font-semibold text-center hover:border-[var(--primary-color)] relative";
                    button.textContent = text;
                    button.onclick = (e) => this.handleQuizAnswer(e, text, correctAnswer);
                    fragment.appendChild(button);
                });
                dom.quizOptions.appendChild(fragment);

                updateProgressDisplay();
                speak(questionText);
            }

            handleQuizAnswer(e, selected, correct) {
                e.stopPropagation();
                if (this.isAnswered) return;
                this.isAnswered = true;
                dom.quizNextButton.classList.add('visible');

                const wasCorrect = selected === correct;
                Array.from(dom.quizOptions.children).forEach(btn => {
                    const isCorrect = btn.textContent === correct;
                    const isSelected = btn.textContent === selected;
                    btn.disabled = true;
                    if (isCorrect) {
                        btn.classList.add('border-[var(--success-color)]', 'bg-[var(--success-bg-color)]');
                        btn.innerHTML += '<span class="absolute right-4 top-1/2 -translate-y-1/2 text-2xl text-[var(--success-color)]">✔</span>';
                    }
                    if (isSelected && !isCorrect) {
                        btn.classList.add('border-[var(--danger-color)]', 'bg-[var(--danger-bg-color)]');
                        btn.innerHTML += '<span class="absolute right-4 top-1/2 -translate-y-1/2 text-2xl text-[var(--danger-color)]">✖</span>';
                    }
                });
                
                if (state.uiSettings.quizAnswerReadAloud) speak(correct);
                playSound(wasCorrect);
                this.processResult(wasCorrect);
            }

            async processResult(wasCorrect) {
                if (this.isProcessing) return;
                this.isProcessing = true;

                try {
                    const card = this.cards[this.currentIndex];
                    if (!card) return;

                    if (wasCorrect) {
                        this.correctCards.push(card);
                    } else {
                        this.incorrectCards.push(card);
                    }
                    
                    if (this.sessionType !== 'retry') {
                        let scoreChange = 0;
                        if (state.uiSettings.learningMode === 'quiz') {
                            const time = (Date.now() - this.startTime) / 1000;
                            if(!wasCorrect) scoreChange = 5;
                            else if (time > 3) scoreChange = 2;
                            else scoreChange = -1;
                        } else {
                            scoreChange = wasCorrect ? -1 : 3;
                        }
                        
                        card.consecutiveCorrect = wasCorrect ? (card.consecutiveCorrect || 0) + 1 : 0;
                        card.nigatescore = Math.max(0, (card.nigatescore || 0) + scoreChange);
                        const interval = wasCorrect ? Math.pow(2, Math.max(0, card.consecutiveCorrect - 1)) : 1;
                        card.nextReviewDate = Date.now() + interval * 24 * 60 * 60 * 1000;
                        card.history = [wasCorrect, ...(card.history || [])].slice(0, 3);
                        
                        await dbOps.updateCard(card);
                    }

                    if (state.uiSettings.learningMode === 'card') {
                        setTimeout(() => this.next(), 200);
                    } else {
                        this.isProcessing = false;
                    }
                } catch (error) {
                    console.error("Error processing card result:", error);
                    this.isProcessing = false;
                }
            }
            
            next() {
                this.currentIndex++;
                if (this.currentIndex >= this.cards.length) {
                    showResultScreen();
                } else {
                    state.uiSettings.learningMode === 'card' ? this.showFlashcard() : this.showQuiz();
                }
            }
        }

        function initDOMElements() {
            Object.assign(dom, {
                screens: { home: document.getElementById('home-screen'), deck: document.getElementById('deck-screen'), study: document.getElementById('study-screen'), settings: document.getElementById('settings-screen'), result: document.getElementById('result-screen') },
                deckLoading: document.getElementById('deck-loading'),
                deckGrid: document.getElementById('deck-grid'),
                searchBar: document.getElementById('search-bar'),
                deckTitleHeader: document.getElementById('deck-title-header'),
                cardListContainer: document.getElementById('card-list-container'),
                addCardForm: document.getElementById('add-card-form'),
                newCardFrontInput: document.getElementById('new-card-front'),
                newCardBackInput: document.getElementById('new-card-back'),
                addDeckModal: document.getElementById('add-deck-modal'),
                newDeckTitleInput: document.getElementById('new-deck-title-input'),
                flashcardInner: document.getElementById('flashcard-inner'),
                flashcardFront: document.getElementById('flashcard-front'),
                flashcardBack: document.getElementById('flashcard-back'),
                flashcardMode: document.getElementById('flashcard-mode'),
                quizMode: document.getElementById('quiz-mode'),
                quizQuestion: document.getElementById('quiz-question'),
                quizOptions: document.getElementById('quiz-options'),
                quizNextButton: document.getElementById('quiz-next-button'),
                toggleMode: document.getElementById('toggle-mode'),
                homeToggleDirection: document.getElementById('home-toggle-direction'),
                resultScreen: {
                    fill: document.getElementById('result-progress-fill'),
                    accuracyPercent: document.getElementById('result-accuracy-percent'),
                    time: document.getElementById('result-time'),
                    correctCount: document.getElementById('result-correct-count'),
                    incorrectCount: document.getElementById('result-incorrect-count'),
                    retryButton: document.getElementById('retry-incorrect-button'),
                    detailsButton: document.getElementById('show-details-button')
                },
                detailsModal: document.getElementById('details-modal'),
            });
        }
        
        function setupEventListeners() {
            document.querySelectorAll('.modal').forEach(modal => {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.classList.add('opacity-0', 'pointer-events-none');
                    }
                });
            });
            document.querySelectorAll('.cancel-modal-button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.target.closest('.modal').classList.add('opacity-0', 'pointer-events-none');
                });
            });
            
            document.getElementById('add-deck-button').addEventListener('click', () => dom.addDeckModal.classList.remove('opacity-0', 'pointer-events-none'));
            document.getElementById('confirm-add-deck').addEventListener('click', async () => {
                const title = dom.newDeckTitleInput.value.trim();
                if (title) {
                    await dbOps.addDeck({ title, createdAt: Date.now(), progress: 0 });
                    await refreshDecks();
                    dom.newDeckTitleInput.value = '';
                    dom.addDeckModal.classList.add('opacity-0', 'pointer-events-none');
                }
            });
            
            document.getElementById('back-to-home-button').addEventListener('click', () => { refreshDecks(); showScreen('home'); });
            document.getElementById('exit-study-button').addEventListener('click', async () => { await refreshDecks(); showScreen('home'); });
            document.getElementById('settings-button').addEventListener('click', () => { showScreen('settings'); updateSettingsUI(); });
            document.getElementById('back-to-home-from-settings').addEventListener('click', () => showScreen('home'));
            dom.searchBar.addEventListener('input', () => renderDecks(state.allDecksCache));
            
            dom.addCardForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const front = dom.newCardFrontInput.value.trim();
                const back = dom.newCardBackInput.value.trim();
                if (front && back && state.currentDeckId) {
                    await dbOps.addCard({ deckId: state.currentDeckId, front, back, createdAt: Date.now(), consecutiveCorrect: 0, nextReviewDate: Date.now(), nigatescore: 0, tags: [] });
                    state.currentDeckCards = await dbOps.getCardsByDeck(state.currentDeckId);
                    renderCards();
                    renderTagFilters();
                    dom.addCardForm.reset();
                    dom.newCardFrontInput.focus();
                }
            });

            dom.cardListContainer.addEventListener('click', async (e) => {
                const cardItem = e.target.closest('.card-item');
                if (!cardItem) return;
                
                const cardId = Number(cardItem.dataset.cardId);

                if (!Number.isFinite(cardId) || cardId <= 0) {
                    console.error("Invalid or missing card ID. Aborting operation.", cardItem.dataset.cardId);
                    return; 
                }

                if (e.target.closest('.delete-card-button')) {
                    showConfirmModal("このカードを本当に削除しますか？", async () => {
                        await dbOps.deleteCard(cardId);
                        state.currentDeckCards = await dbOps.getCardsByDeck(state.currentDeckId);
                        renderCards();
                        renderTagFilters();
                    });
                } 
                else if(e.target.closest('.edit-card-button')) {
                    const card = await dbOps.getCard(cardId);
                    if(card) {
                        cardItem.innerHTML = createCardEditView(card);
                    }
                }
                else if (e.target.closest('.save-card-button')) {
                    const card = await dbOps.getCard(cardId);
                    if(card) {
                        card.front = cardItem.querySelector('.edit-front-input').value.trim();
                        card.back = cardItem.querySelector('.edit-back-input').value.trim();
                        const tagsStr = cardItem.querySelector('.edit-tags-input').value.trim();
                        card.tags = tagsStr.split(',').map(t => t.trim().replace(/^#/, '')).filter(Boolean).map(t => `#${t}`);
                        await dbOps.updateCard(card);
                        state.currentDeckCards = await dbOps.getCardsByDeck(state.currentDeckId);
                        renderCards();
                        renderTagFilters();
                    }
                }
                else if (e.target.closest('.cancel-edit-button')) {
                    const card = await dbOps.getCard(cardId);
                    if(card) {
                        cardItem.innerHTML = createCardView(card);
                    }
                }
                else if (e.target.closest('.card-front-div')) {
                    const frontText = cardItem.querySelector('.card-front-text');
                    if (frontText) speak(frontText.textContent);
                }
                else if (e.target.closest('.card-back-div')) {
                    const backText = cardItem.querySelector('.card-back-text');
                    if(backText) speak(backText.textContent);
                }
            });

            document.getElementById('delete-deck-button').addEventListener('click', async () => {
                showConfirmModal("この単語帳と中のすべてのカードを本当に削除しますか？", async () => {
                    if (state.currentDeckId) {
                        await dbOps.deleteDeck(state.currentDeckId);
                        await refreshDecks();
                        showScreen('home');
                    }
                });
            });

            document.getElementById('csv-import-button').addEventListener('click', () => {
                document.getElementById('csv-file-input').click();
            });
            document.getElementById('csv-file-input').addEventListener('change', (e) => {
                if(e.target.files.length > 0) handleCsvImport(e.target.files[0]);
                e.target.value = '';
            });

            dom.toggleMode.addEventListener('click', () => {
                saveSetting('learningMode', state.uiSettings.learningMode === 'card' ? 'quiz' : 'card');
                updateModeButton();
            });

            dom.homeToggleDirection.addEventListener('click', () => {
                const current = state.uiSettings.cardDirection;
                const next = current === 'front' ? 'back' : (current === 'back' ? 'random' : 'front');
                saveSetting('cardDirection', next);
                updateDirectionUI();
            });
            
            dom.flashcardInner.addEventListener('click', (e) => {
                e.currentTarget.parentElement.classList.toggle('is-flipped');
            });
            document.getElementById('flashcard-speak-button').addEventListener('click', () => {
                if (!currentSession) return;
                const isFlipped = dom.flashcardInner.parentElement.classList.contains('is-flipped');
                const text = isFlipped ? dom.flashcardBack.textContent : dom.flashcardFront.textContent;
                speak(text);
            });
            document.getElementById('quiz-question').addEventListener('click', (e) => speak(e.target.textContent));
            document.getElementById('study-screen').addEventListener('click', (e) => {
                if (currentSession && state.uiSettings.learningMode === 'quiz' && currentSession.isAnswered) {
                    if (e.target.closest('#quiz-options button, #quiz-next-button')) {
                        return;
                    }
                    currentSession.next();
                }
            });
            dom.quizNextButton.addEventListener('click', () => currentSession?.next());

            document.getElementById('familiar-button').addEventListener('click', () => currentSession?.processResult(true));
            document.getElementById('unfamiliar-button').addEventListener('click', () => currentSession?.processResult(false));
            document.getElementById('tag-filter-bar').addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button) {
                    state.currentTagFilter = button.dataset.tag === 'null' ? null : button.dataset.tag;
                    renderCards();
                    renderTagFilters();
                }
            });

            setupSlidingPillControl('theme-selector', 'theme', updateTheme);
            setupSlidingPillControl('question-count-buttons', 'questionCount');
            setupSlidingPillControl('direction-selector', 'cardDirection', updateDirectionUI);
            
            const speechToggle = document.getElementById('speech-enabled-toggle');
            const speechSubPanel = document.querySelector('#speech-settings-card .sub-settings-panel');
            speechToggle.addEventListener('change', (e) => {
                saveSetting('speechEnabled', e.target.checked);
                speechSubPanel.classList.toggle('active', e.target.checked);
            });

            document.querySelectorAll('#speech-settings-card .accordion-header').forEach(header => {
                header.addEventListener('click', () => {
                    if (speechSubPanel.classList.contains('active')) {
                        const content = document.getElementById(header.dataset.target);
                        header.classList.toggle('open');
                        content.classList.toggle('open');
                    }
                });
            });

            document.getElementById('quiz-answer-speak-toggle').addEventListener('change', (e) => saveSetting('quizAnswerReadAloud', e.target.checked));
            
            document.getElementById('en-volume-slider').addEventListener('input', (e) => {
                const volume = parseFloat(e.target.value);
                saveSetting('enVolume', volume);
                document.getElementById('en-volume-value').textContent = volume.toFixed(1);
            });
            document.getElementById('en-rate-slider').addEventListener('input', (e) => {
                const rate = parseFloat(e.target.value);
                saveSetting('enRate', rate);
                document.getElementById('en-rate-value').textContent = rate.toFixed(1);
            });
            document.getElementById('en-voice-select').addEventListener('change', (e) => saveSetting('enVoice', e.target.value));
            
            document.getElementById('ja-volume-slider').addEventListener('input', (e) => {
                const volume = parseFloat(e.target.value);
                saveSetting('jaVolume', volume);
                document.getElementById('ja-volume-value').textContent = volume.toFixed(1);
            });
            document.getElementById('ja-rate-slider').addEventListener('input', (e) => {
                const rate = parseFloat(e.target.value);
                saveSetting('jaRate', rate);
                document.getElementById('ja-rate-value').textContent = rate.toFixed(1);
            });
            document.getElementById('ja-voice-select').addEventListener('change', (e) => saveSetting('jaVoice', e.target.value));

            document.getElementById('result-back-to-home-button').addEventListener('click', async () => { 
                await refreshDecks();
                showScreen('home');
            });
            document.getElementById('retry-incorrect-button').addEventListener('click', () => {
                if(currentSession) {
                    startLearningSession(currentSession.deckId, 'retry', currentSession.incorrectCards);
                }
            });
            document.getElementById('show-details-button').addEventListener('click', () => showDetailsModal(true));
            document.getElementById('progress-container').addEventListener('click', () => showDetailsModal(false));
            document.getElementById('close-details-modal').addEventListener('click', () => {
                document.getElementById('details-modal').classList.add('opacity-0', 'pointer-events-none');
            });
        }
        
        const showDetailsModal = (isFinalResult) => {
            if(!currentSession) return;
            const { cards, correctCards, incorrectCards, currentIndex } = currentSession;
            const currentCards = isFinalResult ? cards : cards.slice(0, currentIndex + 1);
            
            if (currentCards.length === 0) {
                showToast('まだ回答済みのカードがありません。');
                return;
            }

            const title = isFinalResult 
                ? `セッション詳細 (${cards.length}問)` 
                : `学習の途中結果 (${isFinalResult ? cards.length : currentIndex + 1}/${cards.length}問)`;
            
            document.getElementById('details-list-title').textContent = title;
            const listEl = document.getElementById('details-list-container');
            listEl.innerHTML = '';
            const ul = document.createElement('ul');
            ul.className = 'review-list';
            
            const correctIds = new Set(correctCards.map(c => c.id));
            const correctIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="var(--success-color)" stroke="var(--card-bg-color)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle></svg>`;
            const incorrectIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="var(--danger-color)" stroke="var(--card-bg-color)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>`;

            currentCards.forEach(card => {
                const li = document.createElement('li');
                const isCorrect = correctIds.has(card.id);
                li.innerHTML = `
                    <div class="front-back-group">
                        <span class="front">${escapeHTML(card.front)}</span>
                        <span class="back">${escapeHTML(card.back)}</span>
                    </div>
                    <div class="flex-shrink-0">${isCorrect ? correctIcon : incorrectIcon}</div>
                `;
                ul.appendChild(li);
            });
            listEl.appendChild(ul);
            document.getElementById('details-modal').classList.remove('opacity-0', 'pointer-events-none');
        };

        async function initializeApp() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch(e) {
                console.warn('Web Audio API is not supported in this browser');
            }
            initDOMElements();
            setupEventListeners();
            loadSettings();
            
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = populateVoiceList;
            } else {
                populateVoiceList();
            }
            try {
                await dbOps.initDB();
                await checkAndCreateSampleData();
                await refreshDecks();
                dom.deckLoading.style.display = 'none';
            } catch (error) {
                console.error("アプリの初期化に失敗しました:", error);
                dom.deckLoading.textContent = "アプリの起動に失敗しました。";
                dom.deckLoading.style.color = 'red';
            }
        }
    </script>
</body>
</html>
